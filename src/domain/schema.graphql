# WORKAROUND: there's no `console.log` functionality in mapping.
# so we use `debug(..)` which writes a `Debug` entity to the store so you can see them in graphiql.
type Debug @entity {
	id: ID!
	message: String!
}

enum Outcome {
	Pass
	Fail
}

type DAO @entity {
	id: ID!
	name: String!
	nativeToken: Token!
	nativeReputation: Rep!
	proposals: [Proposal!] @derivedFrom(field: "dao")
	members: [Member!] @derivedFrom(field: "dao")
	membersCount: BigInt!
	rewards: [GPReward!] @derivedFrom(field: "dao")
	threshold: BigInt!
}

type Rep @entity {
	id: ID!
	dao: DAO
	totalSupply: BigInt!
}

type Token @entity {
	id: ID!
	dao: DAO
	name: String!
	symbol: String!
	totalSupply: BigInt!
}

type Proposal @entity {
	id: ID!
	dao: DAO!
	proposer: Bytes!
	stage: String!
	createdAt: BigInt!
	preBoostedAt: BigInt
	boostedAt: BigInt
	quietEndingPeriodBeganAt: BigInt
	executedAt: BigInt
	totalRepWhenExecuted: BigInt
	votingMachine: Bytes!
	executionState: String!
	paramsHash: Bytes!
	organizationId: Bytes!
	confidenceThreshold: BigInt!

	descriptionHash: String!
	title: String
	description: String
	url: String

	gpRewards: [GPReward!] @derivedFrom(field: "proposal")
	expiresInQueueAt: BigInt!

	votes: [ProposalVote!] @derivedFrom(field: "proposal")
	votesFor: BigInt!
	votesAgainst: BigInt!
	winningOutcome: Outcome!

	stakes: [ProposalStake!] @derivedFrom(field: "proposal")
	stakesFor: BigInt!
	stakesAgainst: BigInt!

	# Genesis Protocol params
	queuedVoteRequiredPercentage: BigInt!
	queuedVotePeriodLimit: BigInt!
	boostedVotePeriodLimit: BigInt!
	preBoostedVotePeriodLimit: BigInt!
	thresholdConst: BigInt!
	limitExponentValue: BigInt!
	quietEndingPeriod: BigInt!
	proposingRepReward: BigInt!
	votersReputationLossRatio: BigInt!
	minimumDaoBounty: BigInt!
	daoBountyConst: BigInt!
	activationTime: BigInt!
	voteOnBehalf: Bytes!

	# Contribution Reward params
	beneficiary: Bytes!
	reputationReward: BigInt!
	nativeTokenReward: BigInt!
	ethReward: BigInt!
	externalTokenReward: BigInt!
	externalToken: Bytes!
	periods: BigInt!
	periodLength: BigInt!
}

type ProposalStake @entity {
	id: ID!
	createdAt: BigInt!
	staker: Bytes!
	proposal: Proposal!
	outcome: Outcome!
	amount: BigInt!
}

type ProposalVote @entity {
	id: ID!
	createdAt: BigInt!
	voter: Bytes!
	proposal: Proposal!
	outcome: Outcome!
	reputation: BigInt!
}

type Member @entity {
	id: ID!
	dao: DAO!
	address: Bytes!
	reputation: BigInt!
	tokens: BigInt
}

enum RewardReason {
	Contribution
	Proposer
	Voter
	Staker
	Bounty
}

enum RewardType {
	Reputation
	Token
	ETH
	External
}

type GPRewardsHelper @entity {
   id: ID!
	 gpRewards: [GPReward!]
}

type GPReward @entity {
	id: ID!
	createdAt: BigInt!
	dao: DAO!
	beneficiary: Bytes!
	proposal: Proposal!
	reputationForVoter: BigInt
	tokensForStaker: BigInt
	daoBountyForStaker: BigInt
	reputationForProposer: BigInt
	redeemedReputationForVoter: BigInt!
	redeemedTokensForStaker: BigInt!
	redeemedReputationForProposer: BigInt!
	redeemedDaoBountyForStaker: BigInt!
	tokenAddress: Bytes
	redeemed: BigInt!
}

type FirstRegisterSchemeFlag @entity {
	id: ID!
}
